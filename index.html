<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://maps.googleapis.com https://maps.gstatic.com https://gstatic.com; connect-src 'self' https://maps.googleapis.com https://overpass-api.de https://maps.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' https://*.googleapis.com https://*.gstatic.com http://maps.google.com;">
  <title>AmpelFrei ‚Äî Weniger Ampeln, mehr Fahrt</title>
  <link rel="preconnect" href="https://maps.googleapis.com">
  <style>
    /* Dein bestehendes CSS hier einf√ºgen ‚Äì unver√§ndert */
    :root {
      --bg: #0f1115;
      --card: #121417;
      --muted: #9aa3b2;
      --accent: #00d084;
      --danger: #ff5252;
      --glass: rgba(255,255,255,0.03);
      --radius: 12px;
      --shadow: 0 4px 16px rgba(2,6,23,0.5);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color-scheme: dark;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      background: linear-gradient(180deg, #0b0c0e, #0f1115);
      color: #e6eef8;
      -webkit-font-smoothing: antialiased;
      font-size: 16px;
      display: flex;
      flex-direction: column;
      padding: 12px;
    }
    .app {
      max-width: 600px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      margin-bottom: 12px;
    }
    header h1 {
      font-size: 20px;
      font-weight: 600;
    }
    header .sub {
      color: var(--muted);
      font-size: 14px;
      text-align: center;
    }
    .tab-nav {
      display: flex;
      gap: 8px;
      background: var(--glass);
      border-radius: var(--radius);
      padding: 4px;
      position: sticky;
      top: 12px;
      z-index: 10;
    }
    .tab-nav button {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--muted);
      padding: 10px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.2s, color 0.2s;
    }
    .tab-nav button.active {
      background: var(--accent);
      color: #061012;
      font-weight: 600;
    }
    .tab-nav button:hover:not(.active) {
      background: rgba(255,255,255,0.05);
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .panel {
      background: var(--card);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
    }
    .panel h2 {
      font-size: 16px;
      margin-bottom: 12px;
    }
    .form-row {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    label {
      color: var(--muted);
      font-size: 14px;
    }
    input[type="text"], select {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.08);
      color: inherit;
      padding: 12px;
      border-radius: 8px;
      font-size: 16px;
      outline: none;
      width: 100%;
      min-height: 44px;
    }
    input::placeholder {
      color: rgba(255,255,255,0.3);
    }
    .small-btn, .action-btn, .primary {
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      min-height: 44px;
      text-align: center;
    }
    .small-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.08);
      color: inherit;
    }
    .primary {
      background: linear-gradient(90deg, var(--accent), #00c37a);
      color: #061012;
      border: none;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0,208,132,0.15);
    }
    .action-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.08);
      color: inherit;
    }
    .action-btn.secondary {
      border-color: rgba(255,255,255,0.04);
    }
    .toggle-enabled {
      background: rgba(0,208,132,0.15);
      color: var(--accent);
      border: 1px solid rgba(0,208,132,0.2);
    }
    .toggle-disabled {
      background: rgba(255,82,82,0.08);
      color: var(--danger);
      border: 1px solid rgba(255,82,82,0.1);
    }
    .muted {
      color: var(--muted);
      font-size: 14px;
      margin-top: 12px;
    }
    .rides-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
    }
    .ride {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      border-radius: 8px;
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
    }
    .ride .meta {
      font-size: 14px;
    }
    .ride .meta .sub {
      color: var(--muted);
      font-size: 12px;
    }
    #result {
      margin-top: 12px;
      padding: 12px;
      border-radius: 8px;
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
      color: var(--muted);
      font-size: 14px;
    }
    #map {
      height: 300px;
      width: 100%;
      border-radius: var(--radius);
      margin-top: 12px;
      position: relative;
    }
    #map-fallback {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--muted);
      text-align: center;
      background: var(--card);
      padding: 16px;
      border-radius: var(--radius);
    }
    @media (min-width: 600px) {
      .app {
        max-width: 800px;
      }
      header {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
      .tab-nav {
        padding: 6px;
      }
      .tab-nav button {
        font-size: 16px;
      }
      .form-row {
        flex-direction: row;
        gap: 16px;
      }
      .panel {
        padding: 20px;
      }
      .panel h2 {
        font-size: 18px;
      }
    }
    @media (min-width: 900px) {
      .app {
        max-width: 1000px;
      }
    }
  </style>
</head>
<body>
  <div class="app" role="application">
    <header>
      <div>
        <h1>AmpelFrei</h1>
        <div class="sub">Weniger Ampeln, fl√ºssiger fahren ‚Äî f√ºr Auto & Fahrrad</div>
      </div>
      <button id="reportTrafficLightBtn" class="small-btn">üö¶ Ampel melden</button>
    </header>
    <div class="tab-nav">
      <button class="tab-btn active" data-tab="adhoc">Ad-hoc</button>
      <button class="tab-btn" data-tab="routes">Routen</button>
    </div>
    <div id="adhoc" class="tab-content active">
      <div class="panel" aria-live="polite">
        <h2>Ad-hoc-Berechnung</h2>
        <div class="form-row">
          <div class="field">
            <label>Startadresse</label>
            <input id="startAddress" type="text" placeholder="z. B. Musterstra√üe 1, 10115 Berlin" autocomplete="off">
          </div>
          <div class="field">
            <label>Zieladresse</label>
            <input id="destAddress" type="text" placeholder="z. B. Bahnhofstra√üe 5" autocomplete="off">
          </div>
        </div>
        <div class="form-row">
          <div class="field">
            <label>Transportmittel</label>
            <select id="travelMode">
              <option value="DRIVING" selected>Auto</option>
              <option value="BICYCLING">Fahrrad</option>
            </select>
          </div>
          <div class="field">
            <label>Routenpriorit√§t</label>
            <select id="routePriority">
              <option value="traffic_lights" selected>Wenigste Ampeln</option>
              <option value="fastest">Schnellste Route</option>
              <option value="shortest">K√ºrzeste Route</option>
            </select>
          </div>
        </div>
        <div class="form-row">
          <button class="primary" onclick="calculateRoute()">Berechnen: Beste Route finden</button>
          <button class="action-btn secondary" id="saveStartBtn">Start speichern</button>
          <button class="action-btn secondary" id="saveDestBtn">Ziel speichern</button>
        </div>
        <div id="map">
          <div id="map-fallback">Karte konnte nicht geladen werden. Bitte Adblocker deaktivieren oder API-Key pr√ºfen.</div>
        </div>
        <div id="result" class="muted">Ergebnis erscheint hier.</div>
      </div>
    </div>
    <div id="routes" class="tab-content">
      <div class="panel">
        <h2>Neue Route</h2>
        <div class="form-row">
          <div class="field">
            <label>Titel</label>
            <input id="rideTitle" type="text" placeholder="z. B. Zur Arbeit">
          </div>
        </div>
        <div class="form-row">
          <div class="field">
            <label>Startadresse</label>
            <input id="rideOrigin" type="text" placeholder="Start (Autocomplete)">
          </div>
          <div class="field">
            <label>Zieladresse</label>
            <input id="rideDestination" type="text" placeholder="Ziel (Autocomplete)">
          </div>
        </div>
        <div class="form-row">
          <div class="field">
            <label>Transportmittel</label>
            <select id="rideTravelMode">
              <option value="DRIVING" selected>Auto</option>
              <option value="BICYCLING">Fahrrad</option>
            </select>
          </div>
          <div class="field">
            <label>Routenpriorit√§t</label>
            <select id="ridePriority">
              <option value="traffic_lights" selected>Wenigste Ampeln</option>
              <option value="fastest">Schnellste Route</option>
              <option value="shortest">K√ºrzeste Route</option>
            </select>
          </div>
        </div>
        <div class="form-row">
          <button class="primary" onclick="saveRoute()">Route speichern</button>
          <button class="action-btn secondary" onclick="clearRouteForm()">Form l√∂schen</button>
        </div>
        <div class="rides-list">
          <h3 style="margin: 12px 0 8px; font-size: 16px; color: #dfe9f3">Deine Routen</h3>
          <div id="routesList" class="rides-list"></div>
        </div>
      </div>
    </div>
  </div>
  <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCfmA_2wFMG2eXCJF0stxziBnM4CVNpoB0&libraries=places,directions,geometry"></script>
  <script>
    const KEY_ROUTES = 'ampelfrei_routes_v1';
    const KEY_START = 'ampelfrei_start_v1';
    const KEY_DEST = 'ampelfrei_dest_v1';
    let acStart, acDest, acRideOrigin, acRideDest;
    let map, directionsService, directionsRenderer;
    const CACHE = {};
    let hasGeometry = false; // Flag f√ºr Geometry-Fallback

    // Tab-Navigation
    document.querySelectorAll('.tab-btn').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        button.classList.add('active');
        document.getElementById(button.dataset.tab).classList.add('active');
      });
    });

    function showResult(msg, type) {
      const el = document.getElementById('result');
      el.innerHTML = msg;
      el.className = type ? type : 'muted';
    }

    function showLoading(show) {
      const loading = document.getElementById('loading') || document.createElement('div');
      loading.id = 'loading';
      loading.style = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--card); padding: 16px; border-radius: var(--radius); color: var(--muted); z-index: 1000;';
      loading.textContent = 'Lade Route...';
      if (show) document.body.appendChild(loading);
      else if (loading.parentNode) document.body.removeChild(loading);
    }

    function whenMapsReady(cb, timeout = 15000, start = Date.now()) {
      if (window.google && google.maps && google.maps.places && google.maps.directions && google.maps.DirectionsService) {
        hasGeometry = !!google.maps.geometry; // Pr√ºfe Geometry
        if (!hasGeometry) console.warn('Geometry Library nicht geladen ‚Äì Fallback f√ºr Distanzberechnung verwendet.');
        return cb();
      }
      if (Date.now() - start > timeout) {
        let errorMsg = 'Fehler: Google Maps API konnte nicht geladen werden. ';
        if (!window.google) errorMsg += 'Skript nicht geladen (Adblocker?). ';
        else if (!google.maps.directions) errorMsg += 'Directions Library fehlt ‚Äì API-Key pr√ºfen.<grok-card data-id="7fbee5" data-type="citation_card"></grok-card> ';
        else if (!hasGeometry) errorMsg += 'Geometry Library fehlt ‚Äì Docs: https://developers.google.com/maps/documentation/javascript/geometry.<grok-card data-id="6e43fc" data-type="citation_card"></grok-card> ';
        errorMsg += 'Deaktiviere Adblocker und pr√ºfe API-Key.';
        showResult(errorMsg, 'danger');
        console.error('Google Maps API Timeout:', errorMsg);
        document.getElementById('map-fallback').style.display = 'block';
        return;
      }
      showResult('Google Maps API wird geladen...', 'muted');
      setTimeout(() => whenMapsReady(cb, timeout, start), 500);
    }

    // Initialisiere Google Maps
    whenMapsReady(() => {
      try {
        map = new google.maps.Map(document.getElementById('map'), {
          zoom: 12,
          center: { lat: 52.52, lng: 13.405 }, // Berlin als Default
          mapTypeControl: false,
          streetViewControl: false,
          styles: [
            { elementType: "geometry", stylers: [{ color: "#212121" }] },
            { elementType: "labels.text.stroke", stylers: [{ color: "#212121" }] },
            { elementType: "labels.text.fill", stylers: [{ color: "#746855" }] },
            { featureType: "road", elementType: "geometry", stylers: [{ color: "#3d3d3d" }] },
            { featureType: "road", elementType: "labels.text.fill", stylers: [{ color: "#9aa3b2" }] },
          ]
        });
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({ map: map });
        acStart = new google.maps.places.Autocomplete(document.getElementById('startAddress'));
        acDest = new google.maps.places.Autocomplete(document.getElementById('destAddress'));
        acRideOrigin = new google.maps.places.Autocomplete(document.getElementById('rideOrigin'));
        acRideDest = new google.maps.places.Autocomplete(document.getElementById('rideDestination'));
        document.getElementById('map-fallback').style.display = 'none';
        showResult('Google Maps initialisiert (Geometry: ' + (hasGeometry ? 'Ja' : 'Nein') + ')', 'success');
      } catch (e) {
        document.getElementById('map-fallback').style.display = 'block';
        showResult('Fehler beim Laden der Karte: ' + e.message, 'danger');
        console.error('Maps Initialisierungsfehler:', e);
      }
    });

    // Fallback f√ºr Distanzberechnung ohne Geometry
    function computeDistanceFallback(lat1, lng1, lat2, lng2) {
      const R = 6371e3; // Erdradius in Metern
      const œÜ1 = lat1 * Math.PI / 180;
      const œÜ2 = lat2 * Math.PI / 180;
      const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
      const ŒîŒª = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c; // in Metern
    }

    function saveStart() {
      localStorage.setItem(KEY_START, document.getElementById('startAddress').value);
      showResult('Startadresse gespeichert', 'success');
    }

    function saveDest() {
      localStorage.setItem(KEY_DEST, document.getElementById('destAddress').value);
      showResult('Zieladresse gespeichert', 'success');
    }

    document.getElementById('saveStartBtn').onclick = saveStart;
    document.getElementById('saveDestBtn').onclick = saveDest;

    function loadRoutes() {
      const r = localStorage.getItem(KEY_ROUTES);
      return r ? JSON.parse(r) : [];
    }

    function saveRoutes(routes) {
      localStorage.setItem(KEY_ROUTES, JSON.stringify(routes));
      renderRoutes();
    }

    function clearRouteForm() {
      document.getElementById('rideTitle').value = '';
      document.getElementById('rideOrigin').value = '';
      document.getElementById('rideDestination').value = '';
      document.getElementById('rideTravelMode').value = 'DRIVING';
      document.getElementById('ridePriority').value = 'traffic_lights';
    }

    function saveRoute() {
      const routes = loadRoutes();
      const id = Date.now();
      const r = {
        id,
        title: document.getElementById('rideTitle').value || 'unnamed',
        originAddress: document.getElementById('rideOrigin').value,
        destinationAddress: document.getElementById('rideDestination').value,
        travelMode: document.getElementById('rideTravelMode').value,
        priority: document.getElementById('ridePriority').value,
        enabled: true
      };
      routes.push(r);
      saveRoutes(routes);
      clearRouteForm();
    }

    function deleteRoute(id) {
      const routes = loadRoutes().filter(r => r.id !== id);
      saveRoutes(routes);
    }

    async function getTrafficLights(points) {
      const cacheKey = points.map(p => `${p.lat}_${p.lng}`).join('|');
      if (CACHE[cacheKey]) return CACHE[cacheKey];
      const bounds = points.reduce((b, p) => ({
        minLat: Math.min(b.minLat, p.lat),
        maxLat: Math.max(b.maxLat, p.lat),
        minLng: Math.min(b.minLng, p.lng),
        maxLng: Math.max(b.maxLng, p.lng)
      }), { minLat: Infinity, maxLat: -Infinity, minLng: Infinity, maxLng: -Infinity });
      const query = `[out:json];node["highway"="traffic_signals"](${bounds.minLat},${bounds.minLng},${bounds.maxLat},${bounds.maxLng});out;`;
      try {
        const response = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: `data=${encodeURIComponent(query)}` });
        if (response.ok) {
          const data = await response.json();
          const signals = data.elements;
          let count = 0;
          signals.forEach(signal => {
            const signalPos = { lat: signal.lat, lng: signal.lon };
            const isNear = points.some(p => {
              if (hasGeometry) {
                return google.maps.geometry.spherical.computeDistanceBetween(
                  new google.maps.LatLng(p.lat, p.lng), new google.maps.LatLng(signal.lat, signal.lon)) <= 50;
              } else {
                return computeDistanceFallback(p.lat, p.lng, signal.lat, signal.lon) <= 50;
              }
            });
            if (isNear) {
              count++;
              if (map) {
                new google.maps.Marker({
                  position: signalPos,
                  map: map,
                  icon: { url: 'http://maps.google.com/mapfiles/ms/icons/red.png', scaledSize: new google.maps.Size(20, 20) },
                  title: 'Ampel'
                });
              }
            }
          });
          CACHE[cacheKey] = count;
          return count;
        }
      } catch (e) {
        console.error('OSM Overpass Fehler:', e);
        return 0;
      }
    }

    async function calculateRoute() {
      showLoading(true);
      const startVal = document.getElementById('startAddress').value.trim();
      const destVal = document.getElementById('destAddress').value.trim();
      const travelMode = document.getElementById('travelMode').value;
      const priority = document.getElementById('routePriority').value;

      if (!startVal || !destVal || startVal.length < 3 || destVal.length < 3) {
        showResult('Bitte g√ºltige Start- und Zieladressen eingeben (mind. 3 Zeichen)', 'danger');
        showLoading(false);
        return;
      }

      whenMapsReady(async () => {
        if (!directionsService) {
          showResult('Fehler: Directions API nicht geladen. Pr√ºfe API-Key und Adblocker.', 'danger');
          showLoading(false);
          return;
        }

        console.group('üó∫Ô∏è AmpelFrei Berechnung: ' + startVal + ' ‚Üí ' + destVal);
        const geocoder = new google.maps.Geocoder();
        try {
          console.log('Geocoding Startadresse:', startVal);
          const results1 = await new Promise((resolve, reject) => {
            geocoder.geocode({ address: startVal }, (results, status) => {
              console.log('Geocoding Status (Start):', status);
              if (status === 'OK' && results[0]) resolve(results);
              else reject(new Error('Startadresse nicht gefunden: ' + status));
            });
          });

          console.log('Geocoding Zieladresse:', destVal);
          const results2 = await new Promise((resolve, reject) => {
            geocoder.geocode({ address: destVal }, (results, status) => {
              console.log('Geocoding Status (Ziel):', status);
              if (status === 'OK' && results[0]) resolve(results);
              else reject(new Error('Zieladresse nicht gefunden: ' + status));
            });
          });

          console.log('Rufe Directions API auf...');
          const result = await new Promise((resolve, reject) => {
            directionsService.route({
              origin: startVal,
              destination: destVal,
              travelMode: google.maps.TravelMode[travelMode],
              provideRouteAlternatives: true
            }, (result, status) => {
              console.log('Directions API Status:', status);
              if (status === 'OK') resolve(result);
              else reject(new Error('Route nicht gefunden: ' + status));
            });
          });

          const routes = result.routes;
          let bestRoute = null;
          let minScore = Infinity;
          const routeDetails = [];

          for (let i = 0; i < routes.length; i++) {
            const route = routes[i];
            const leg = route.legs[0];
            const path = route.overview_path.map(p => ({ lat: p.lat(), lng: p.lng() }));
            const trafficLights = await getTrafficLights(path);
            const distance = leg.distance.value / 1000;
            const duration = leg.duration.value / 60;
            let score;
            if (priority === 'traffic_lights') {
              score = trafficLights * 10 + distance;
            } else if (priority === 'fastest') {
              score = duration;
            } else {
              score = distance;
            }
            routeDetails.push({
              index: i,
              trafficLights,
              distance: distance.toFixed(1),
              duration: Math.round(duration),
              score
            });
            if (score < minScore) {
              minScore = score;
              bestRoute = { index: i, trafficLights, distance, duration };
            }
          }

          directionsRenderer.setRouteIndex(bestRoute.index);
          let resultHtml = `<strong>Beste Route (${priority === 'traffic_lights' ? 'Wenigste Ampeln' : priority === 'fastest' ? 'Schnellste' : 'K√ºrzeste'}):</strong><br>`;
          resultHtml += `üö¶ ${bestRoute.trafficLights} Ampeln<br>`;
          resultHtml += `üìè ${bestRoute.distance} km<br>`;
          resultHtml += `‚è± ${bestRoute.duration} Minuten<br>`;
          resultHtml += `<br><strong>Alle Routen (klicke zum Umschalten):</strong><br>`;
          routeDetails.forEach(r => {
            resultHtml += `<a href="#" onclick="directionsRenderer.setRouteIndex(${r.index}); return false;" style="color: var(--accent);">Route ${r.index + 1}</a>: ${r.trafficLights} Ampeln, ${r.distance} km, ${r.duration} Min<br>`;
          });
          showResult(resultHtml, 'success');
          console.log('Routen:', routeDetails);
          console.groupEnd();
        } catch (e) {
          showResult('Fehler bei der Routenberechnung: ' + e.message, 'danger');
          console.error('Routenberechnungsfehler:', e);
          console.groupEnd();
        } finally {
          showLoading(false);
        }
      });
    }

  async function renderRoutes() {
    const list = document.getElementById('routesList');
    const routes = loadRoutes();
    list.innerHTML = routes.length ? '' : '<div class="muted">Keine Routen</div>';
    for (const r of routes) {
      const el = document.createElement('div'); el.className = 'ride';
      const left = document.createElement('div'); left.className = 'meta';
      left.innerHTML = `<strong>${r.title}</strong>
        <div class="sub">${r.originAddress} ‚Üí ${r.destinationAddress}</div>
        <div class="sub">${r.travelMode === 'DRIVING' ? 'Auto' : 'Fahrrad'} ¬∑ Priorit√§t: ${r.priority === 'traffic_lights' ? 'Wenigste Ampeln' : r.priority === 'fastest' ? 'Schnellste' : 'K√ºrzeste'}</div>
        <div class="sub" id="traffic_${r.id}">üö¶ Berechne...</div>`;
      const right = document.createElement('div');
      const toggle = document.createElement('button'); toggle.className = 'action-btn ' + (r.enabled ? 'toggle-enabled' : 'toggle-disabled'); toggle.textContent = r.enabled ? 'Aktiv' : 'Inaktiv';
      toggle.onclick = () => { r.enabled = !r.enabled; saveRoutes(loadRoutes().map(x => x.id === r.id ? r : x)); renderRoutes(); };
      const edit = document.createElement('button'); edit.className = 'action-btn'; edit.textContent = 'Bearbeiten'; edit.onclick = () => loadRouteIntoForm(r.id);
      const del = document.createElement('button'); del.className = 'action-btn secondary'; del.textContent = 'L√∂schen'; del.onclick = () => deleteRoute(r.id);
      right.appendChild(toggle); right.appendChild(edit); right.appendChild(del);
      el.appendChild(left); el.appendChild(right); list.appendChild(el);

      whenMapsReady(async () => {
        if (!directionsService) return;
        const geocoder = new google.maps.Geocoder();
        try {
          const results1 = await new Promise((resolve, reject) => {
            geocoder.geocode({ address: r.originAddress }, (results, status) => {
              if (status === 'OK' && results[0]) resolve(results);
              else reject(new Error('Startadresse nicht gefunden'));
            });
          });
          const results2 = await new Promise((resolve, reject) => {
            geocoder.geocode({ address: r.destinationAddress }, (results, status) => {
              if (status === 'OK' && results[0]) resolve(results);
              else reject(new Error('Zieladresse nicht gefunden'));
            });
          });
          const result = await new Promise((resolve, reject) => {
            directionsService.route({
              origin: r.originAddress,
              destination: r.destinationAddress,
              travelMode: google.maps.TravelMode[r.travelMode],
              provideRouteAlternatives: true
            }, (result, status) => {
              if (status === 'OK') resolve(result);
              else reject(new Error('Route nicht gefunden'));
            });
          });

          const routes = result.routes;
          let bestRoute = null;
          let minScore = Infinity;
          for (let i = 0; i < routes.length; i++) {
            const path = routes[i].overview_path.map(p => ({ lat: p.lat(), lng: p.lng() }));
            const trafficLights = await getTrafficLights(path);
            const distance = routes[i].legs[0].distance.value / 1000;
            const duration = routes[i].legs[0].duration.value / 60;
            let score = r.priority === 'traffic_lights' ? trafficLights * 10 + distance : r.priority === 'fastest' ? duration : distance;
            if (score < minScore) {
              minScore = score;
              bestRoute = { index: i, trafficLights };
            }
          }
          const elp = document.getElementById(`traffic_${r.id}`);
          if (elp) elp.innerHTML = `üö¶ ${bestRoute.trafficLights} Ampeln`;
        } catch (e) {
          console.error('Fehler bei gespeicherter Route:', e);
        }
      });
    }
  }

  function loadRouteIntoForm(id) {
    const r = loadRoutes().find(x => x.id === id); if (!r) return;
    document.getElementById('rideTitle').value = r.title;
    document.getElementById('rideOrigin').value = r.originAddress;
    document.getElementById('rideDestination').value = r.destinationAddress;
    document.getElementById('rideTravelMode').value = r.travelMode;
    document.getElementById('ridePriority').value = r.priority;
    document.querySelector('.tab-btn[data-tab="routes"]').click();
  }

  document.getElementById('reportTrafficLightBtn').onclick = () => {
    showResult('üö¶ Klicke auf die Karte, um eine Ampel zu melden', 'muted');
    const listener = map.addListener('click', (e) => {
      const pos = { lat: e.latLng.lat(), lng: e.latLng.lng() };
      new google.maps.Marker({
        position: pos,
        map: map,
        icon: { url: 'http://maps.google.com/mapfiles/ms/icons/red.png', scaledSize: new google.maps.Size(20, 20) },
        title: 'Gemeldete Ampel'
      });
      showResult(`Ampel bei ${pos.lat.toFixed(4)}, ${pos.lng.toFixed(4)} gemeldet (zuk√ºnftig: an Server senden)`, 'success');
      google.maps.event.removeListener(listener);
    });
  };

  // Init
  renderRoutes();
</script>
</body>
</html>
